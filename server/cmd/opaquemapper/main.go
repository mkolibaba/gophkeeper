//go:build ignore

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"golang.org/x/tools/go/packages"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const templateStr = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by opaquemapper

package {{.Package}}

{{if .Imports}}import (
	{{range .Imports}}"{{.}}"
	{{end}}
){{end}}

type in_{{.Type}} interface {
{{range .Fields}}
	Has{{.In}}() bool
	Get{{.In}}() string
{{end}}
}

func Map{{.Type}}(in in_{{.Type}}) {{.SrcQualifier}}{{.Type}} {
	var out {{.SrcQualifier}}{{.Type}}

	{{range .Fields}}
	if in.Has{{.In}}() {
		v := in.Get{{.In}}()
		out.{{.Out}} = &v
	}
	{{end}}

	return out
}
`

var tmpl = template.Must(template.New("opaque").Parse(templateStr))

type mapping struct {
	Out string
	In  string
}

// opaque to update struct generator
func main() {
	mappings := make(map[string]string)

	pkg := flag.String("pkg", "", "package name")
	out := flag.String("out", "", "output file name")
	flag.Func("mappings", "from to mappings", func(s string) error {
		split := strings.Split(s, ",")
		for _, m := range split {
			ss := strings.Split(m, ":")
			mappings[strings.Trim(ss[0], " ")] = strings.Trim(ss[1], " ")
		}
		return nil
	})
	flag.Parse()

	args := flag.Args()

	filename := os.Getenv("GOFILE")

	srcDir, outType := args[0], args[1]

	srcPkg, err := pkgInfoFromPath(srcDir)
	if err != nil {
		panic(err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, 0)
	if err != nil {
		panic(err)
	}

	var (
		fields  []mapping
		imports []string
	)

	for _, d := range f.Decls {
		var gd *ast.GenDecl
		var ok bool
		if gd, ok = d.(*ast.GenDecl); !ok {
			continue
		}

		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Проверяем, совпадает ли имя типа с нужным нам (outType)
			if ts.Name.Name != outType {
				continue
			}

			// Проверяем, является ли тип структурой
			structType, ok := ts.Type.(*ast.StructType)
			if !ok {
				fmt.Fprintf(os.Stderr, "Type %s is not a struct\n", outType)
				os.Exit(1)
			}

			for _, field := range structType.Fields.List {
				if field.Names != nil {
					for _, name := range field.Names {
						to, ok := mappings[name.Name]
						if ok {
							fields = append(fields, mapping{Out: name.Name, In: to})
						} else {
							fields = append(fields, mapping{Out: name.Name, In: name.Name})
						}
					}
				}
			}
		}
	}

	packageName := *pkg
	if packageName == "" {
		packageName = f.Name.Name
	}

	var srcQualifier string
	if packageName != srcPkg.Name {
		srcQualifier = srcPkg.Name + "."
		imports = append(imports, srcPkg.PkgPath)
	}

	// генерируем код по шаблону
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, map[string]any{
		"Package":      packageName,
		"Type":         outType,
		"Fields":       fields,
		"Imports":      imports,
		"SrcQualifier": srcQualifier,
	})
	if err != nil {
		panic(err)
	}

	// форматируем код
	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	outFilename := *out
	if outFilename == "" {
		basename := strings.TrimSuffix(filename, filepath.Ext(filename))
		outFilename = fmt.Sprintf("%s_mapping.go", basename)
	}

	// записываем сгенерированный код в файл
	dir := filepath.Dir(outFilename)
	err = os.MkdirAll(dir, 0755)
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(outFilename, bufFmt, 0666)
	if err != nil {
		panic(err)
	}
}

func pkgInfoFromPath(srcDir string) (*packages.Package, error) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedSyntax | packages.NeedTypes,
		Dir:  srcDir,
	})
	if err != nil {
		return nil, err
	}
	if len(pkgs) == 0 {
		return nil, errors.New("package not found")
	}
	if len(pkgs) > 1 {
		return nil, errors.New("found more than one package")
	}
	if errs := pkgs[0].Errors; len(errs) != 0 {
		if len(errs) == 1 {
			return nil, errs[0]
		}
		return nil, fmt.Errorf("%s (and %d more errors)", errs[0], len(errs)-1)
	}
	return pkgs[0], nil
}
