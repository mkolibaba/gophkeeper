// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mock

import (
	"context"
	"sync"

	"github.com/mkolibaba/gophkeeper/client"
)

// Ensure that LoginServiceMock does implement client.LoginService.
// If this is not the case, regenerate this file with mockery.
var _ client.LoginService = &LoginServiceMock{}

// LoginServiceMock is a mock implementation of client.LoginService.
//
//	func TestSomethingThatUsesLoginService(t *testing.T) {
//
//		// make and configure a mocked client.LoginService
//		mockedLoginService := &LoginServiceMock{
//			GetAllFunc: func(ctx context.Context) ([]client.LoginData, error) {
//				panic("mock out the GetAll method")
//			},
//			RemoveFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, data client.LoginData) error {
//				panic("mock out the Save method")
//			},
//			UpdateFunc: func(ctx context.Context, data client.LoginDataUpdate) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedLoginService in code that requires client.LoginService
//		// and then make assertions.
//
//	}
type LoginServiceMock struct {
	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context) ([]client.LoginData, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, id int64) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, data client.LoginData) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, data client.LoginDataUpdate) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.LoginData
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.LoginDataUpdate
		}
	}
	lockGetAll sync.RWMutex
	lockRemove sync.RWMutex
	lockSave   sync.RWMutex
	lockUpdate sync.RWMutex
}

// GetAll calls GetAllFunc.
func (mock *LoginServiceMock) GetAll(ctx context.Context) ([]client.LoginData, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	if mock.GetAllFunc == nil {
		var (
			loginDatas []client.LoginData
			err        error
		)
		return loginDatas, err
	}
	return mock.GetAllFunc(ctx)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedLoginService.GetAllCalls())
func (mock *LoginServiceMock) GetAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *LoginServiceMock) Remove(ctx context.Context, id int64) error {
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	if mock.RemoveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.RemoveFunc(ctx, id)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedLoginService.RemoveCalls())
func (mock *LoginServiceMock) RemoveCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *LoginServiceMock) Save(ctx context.Context, data client.LoginData) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.LoginData
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	if mock.SaveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.SaveFunc(ctx, data)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedLoginService.SaveCalls())
func (mock *LoginServiceMock) SaveCalls() []struct {
	Ctx  context.Context
	Data client.LoginData
} {
	var calls []struct {
		Ctx  context.Context
		Data client.LoginData
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *LoginServiceMock) Update(ctx context.Context, data client.LoginDataUpdate) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.LoginDataUpdate
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	if mock.UpdateFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.UpdateFunc(ctx, data)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedLoginService.UpdateCalls())
func (mock *LoginServiceMock) UpdateCalls() []struct {
	Ctx  context.Context
	Data client.LoginDataUpdate
} {
	var calls []struct {
		Ctx  context.Context
		Data client.LoginDataUpdate
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that NoteServiceMock does implement client.NoteService.
// If this is not the case, regenerate this file with mockery.
var _ client.NoteService = &NoteServiceMock{}

// NoteServiceMock is a mock implementation of client.NoteService.
//
//	func TestSomethingThatUsesNoteService(t *testing.T) {
//
//		// make and configure a mocked client.NoteService
//		mockedNoteService := &NoteServiceMock{
//			GetAllFunc: func(ctx context.Context) ([]client.NoteData, error) {
//				panic("mock out the GetAll method")
//			},
//			RemoveFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, data client.NoteData) error {
//				panic("mock out the Save method")
//			},
//			UpdateFunc: func(ctx context.Context, data client.NoteDataUpdate) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedNoteService in code that requires client.NoteService
//		// and then make assertions.
//
//	}
type NoteServiceMock struct {
	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context) ([]client.NoteData, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, id int64) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, data client.NoteData) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, data client.NoteDataUpdate) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.NoteData
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.NoteDataUpdate
		}
	}
	lockGetAll sync.RWMutex
	lockRemove sync.RWMutex
	lockSave   sync.RWMutex
	lockUpdate sync.RWMutex
}

// GetAll calls GetAllFunc.
func (mock *NoteServiceMock) GetAll(ctx context.Context) ([]client.NoteData, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	if mock.GetAllFunc == nil {
		var (
			noteDatas []client.NoteData
			err       error
		)
		return noteDatas, err
	}
	return mock.GetAllFunc(ctx)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedNoteService.GetAllCalls())
func (mock *NoteServiceMock) GetAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *NoteServiceMock) Remove(ctx context.Context, id int64) error {
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	if mock.RemoveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.RemoveFunc(ctx, id)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedNoteService.RemoveCalls())
func (mock *NoteServiceMock) RemoveCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *NoteServiceMock) Save(ctx context.Context, data client.NoteData) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.NoteData
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	if mock.SaveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.SaveFunc(ctx, data)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedNoteService.SaveCalls())
func (mock *NoteServiceMock) SaveCalls() []struct {
	Ctx  context.Context
	Data client.NoteData
} {
	var calls []struct {
		Ctx  context.Context
		Data client.NoteData
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *NoteServiceMock) Update(ctx context.Context, data client.NoteDataUpdate) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.NoteDataUpdate
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	if mock.UpdateFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.UpdateFunc(ctx, data)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedNoteService.UpdateCalls())
func (mock *NoteServiceMock) UpdateCalls() []struct {
	Ctx  context.Context
	Data client.NoteDataUpdate
} {
	var calls []struct {
		Ctx  context.Context
		Data client.NoteDataUpdate
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that BinaryServiceMock does implement client.BinaryService.
// If this is not the case, regenerate this file with mockery.
var _ client.BinaryService = &BinaryServiceMock{}

// BinaryServiceMock is a mock implementation of client.BinaryService.
//
//	func TestSomethingThatUsesBinaryService(t *testing.T) {
//
//		// make and configure a mocked client.BinaryService
//		mockedBinaryService := &BinaryServiceMock{
//			DownloadFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Download method")
//			},
//			GetAllFunc: func(ctx context.Context) ([]client.BinaryData, error) {
//				panic("mock out the GetAll method")
//			},
//			RemoveFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, data client.BinaryData) error {
//				panic("mock out the Save method")
//			},
//			UpdateFunc: func(ctx context.Context, data client.BinaryDataUpdate) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedBinaryService in code that requires client.BinaryService
//		// and then make assertions.
//
//	}
type BinaryServiceMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(ctx context.Context, id int64) error

	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context) ([]client.BinaryData, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, id int64) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, data client.BinaryData) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, data client.BinaryDataUpdate) error

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.BinaryData
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.BinaryDataUpdate
		}
	}
	lockDownload sync.RWMutex
	lockGetAll   sync.RWMutex
	lockRemove   sync.RWMutex
	lockSave     sync.RWMutex
	lockUpdate   sync.RWMutex
}

// Download calls DownloadFunc.
func (mock *BinaryServiceMock) Download(ctx context.Context, id int64) error {
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	mock.lockDownload.Unlock()
	if mock.DownloadFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.DownloadFunc(ctx, id)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//
//	len(mockedBinaryService.DownloadCalls())
func (mock *BinaryServiceMock) DownloadCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDownload.RLock()
	calls = mock.calls.Download
	mock.lockDownload.RUnlock()
	return calls
}

// GetAll calls GetAllFunc.
func (mock *BinaryServiceMock) GetAll(ctx context.Context) ([]client.BinaryData, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	if mock.GetAllFunc == nil {
		var (
			binaryDatas []client.BinaryData
			err         error
		)
		return binaryDatas, err
	}
	return mock.GetAllFunc(ctx)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedBinaryService.GetAllCalls())
func (mock *BinaryServiceMock) GetAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *BinaryServiceMock) Remove(ctx context.Context, id int64) error {
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	if mock.RemoveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.RemoveFunc(ctx, id)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedBinaryService.RemoveCalls())
func (mock *BinaryServiceMock) RemoveCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *BinaryServiceMock) Save(ctx context.Context, data client.BinaryData) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.BinaryData
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	if mock.SaveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.SaveFunc(ctx, data)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedBinaryService.SaveCalls())
func (mock *BinaryServiceMock) SaveCalls() []struct {
	Ctx  context.Context
	Data client.BinaryData
} {
	var calls []struct {
		Ctx  context.Context
		Data client.BinaryData
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *BinaryServiceMock) Update(ctx context.Context, data client.BinaryDataUpdate) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.BinaryDataUpdate
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	if mock.UpdateFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.UpdateFunc(ctx, data)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedBinaryService.UpdateCalls())
func (mock *BinaryServiceMock) UpdateCalls() []struct {
	Ctx  context.Context
	Data client.BinaryDataUpdate
} {
	var calls []struct {
		Ctx  context.Context
		Data client.BinaryDataUpdate
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that CardServiceMock does implement client.CardService.
// If this is not the case, regenerate this file with mockery.
var _ client.CardService = &CardServiceMock{}

// CardServiceMock is a mock implementation of client.CardService.
//
//	func TestSomethingThatUsesCardService(t *testing.T) {
//
//		// make and configure a mocked client.CardService
//		mockedCardService := &CardServiceMock{
//			GetAllFunc: func(ctx context.Context) ([]client.CardData, error) {
//				panic("mock out the GetAll method")
//			},
//			RemoveFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, data client.CardData) error {
//				panic("mock out the Save method")
//			},
//			UpdateFunc: func(ctx context.Context, data client.CardDataUpdate) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedCardService in code that requires client.CardService
//		// and then make assertions.
//
//	}
type CardServiceMock struct {
	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context) ([]client.CardData, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, id int64) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, data client.CardData) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, data client.CardDataUpdate) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.CardData
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data client.CardDataUpdate
		}
	}
	lockGetAll sync.RWMutex
	lockRemove sync.RWMutex
	lockSave   sync.RWMutex
	lockUpdate sync.RWMutex
}

// GetAll calls GetAllFunc.
func (mock *CardServiceMock) GetAll(ctx context.Context) ([]client.CardData, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	if mock.GetAllFunc == nil {
		var (
			cardDatas []client.CardData
			err       error
		)
		return cardDatas, err
	}
	return mock.GetAllFunc(ctx)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedCardService.GetAllCalls())
func (mock *CardServiceMock) GetAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *CardServiceMock) Remove(ctx context.Context, id int64) error {
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	if mock.RemoveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.RemoveFunc(ctx, id)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedCardService.RemoveCalls())
func (mock *CardServiceMock) RemoveCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *CardServiceMock) Save(ctx context.Context, data client.CardData) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.CardData
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	if mock.SaveFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.SaveFunc(ctx, data)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedCardService.SaveCalls())
func (mock *CardServiceMock) SaveCalls() []struct {
	Ctx  context.Context
	Data client.CardData
} {
	var calls []struct {
		Ctx  context.Context
		Data client.CardData
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *CardServiceMock) Update(ctx context.Context, data client.CardDataUpdate) error {
	callInfo := struct {
		Ctx  context.Context
		Data client.CardDataUpdate
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	if mock.UpdateFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.UpdateFunc(ctx, data)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedCardService.UpdateCalls())
func (mock *CardServiceMock) UpdateCalls() []struct {
	Ctx  context.Context
	Data client.CardDataUpdate
} {
	var calls []struct {
		Ctx  context.Context
		Data client.CardDataUpdate
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure that AuthorizationServiceMock does implement client.AuthorizationService.
// If this is not the case, regenerate this file with mockery.
var _ client.AuthorizationService = &AuthorizationServiceMock{}

// AuthorizationServiceMock is a mock implementation of client.AuthorizationService.
//
//	func TestSomethingThatUsesAuthorizationService(t *testing.T) {
//
//		// make and configure a mocked client.AuthorizationService
//		mockedAuthorizationService := &AuthorizationServiceMock{
//			AuthorizeFunc: func(ctx context.Context, login string, password string) (string, error) {
//				panic("mock out the Authorize method")
//			},
//			RegisterFunc: func(ctx context.Context, login string, password string) (string, error) {
//				panic("mock out the Register method")
//			},
//		}
//
//		// use mockedAuthorizationService in code that requires client.AuthorizationService
//		// and then make assertions.
//
//	}
type AuthorizationServiceMock struct {
	// AuthorizeFunc mocks the Authorize method.
	AuthorizeFunc func(ctx context.Context, login string, password string) (string, error)

	// RegisterFunc mocks the Register method.
	RegisterFunc func(ctx context.Context, login string, password string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Authorize holds details about calls to the Authorize method.
		Authorize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Login is the login argument value.
			Login string
			// Password is the password argument value.
			Password string
		}
		// Register holds details about calls to the Register method.
		Register []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Login is the login argument value.
			Login string
			// Password is the password argument value.
			Password string
		}
	}
	lockAuthorize sync.RWMutex
	lockRegister  sync.RWMutex
}

// Authorize calls AuthorizeFunc.
func (mock *AuthorizationServiceMock) Authorize(ctx context.Context, login string, password string) (string, error) {
	callInfo := struct {
		Ctx      context.Context
		Login    string
		Password string
	}{
		Ctx:      ctx,
		Login:    login,
		Password: password,
	}
	mock.lockAuthorize.Lock()
	mock.calls.Authorize = append(mock.calls.Authorize, callInfo)
	mock.lockAuthorize.Unlock()
	if mock.AuthorizeFunc == nil {
		var (
			s   string
			err error
		)
		return s, err
	}
	return mock.AuthorizeFunc(ctx, login, password)
}

// AuthorizeCalls gets all the calls that were made to Authorize.
// Check the length with:
//
//	len(mockedAuthorizationService.AuthorizeCalls())
func (mock *AuthorizationServiceMock) AuthorizeCalls() []struct {
	Ctx      context.Context
	Login    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Login    string
		Password string
	}
	mock.lockAuthorize.RLock()
	calls = mock.calls.Authorize
	mock.lockAuthorize.RUnlock()
	return calls
}

// Register calls RegisterFunc.
func (mock *AuthorizationServiceMock) Register(ctx context.Context, login string, password string) (string, error) {
	callInfo := struct {
		Ctx      context.Context
		Login    string
		Password string
	}{
		Ctx:      ctx,
		Login:    login,
		Password: password,
	}
	mock.lockRegister.Lock()
	mock.calls.Register = append(mock.calls.Register, callInfo)
	mock.lockRegister.Unlock()
	if mock.RegisterFunc == nil {
		var (
			s   string
			err error
		)
		return s, err
	}
	return mock.RegisterFunc(ctx, login, password)
}

// RegisterCalls gets all the calls that were made to Register.
// Check the length with:
//
//	len(mockedAuthorizationService.RegisterCalls())
func (mock *AuthorizationServiceMock) RegisterCalls() []struct {
	Ctx      context.Context
	Login    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Login    string
		Password string
	}
	mock.lockRegister.RLock()
	calls = mock.calls.Register
	mock.lockRegister.RUnlock()
	return calls
}

// Ensure that UserServiceMock does implement client.UserService.
// If this is not the case, regenerate this file with mockery.
var _ client.UserService = &UserServiceMock{}

// UserServiceMock is a mock implementation of client.UserService.
//
//	func TestSomethingThatUsesUserService(t *testing.T) {
//
//		// make and configure a mocked client.UserService
//		mockedUserService := &UserServiceMock{
//			GetBearerTokenFunc: func() string {
//				panic("mock out the GetBearerToken method")
//			},
//			GetUserLoginFunc: func() string {
//				panic("mock out the GetUserLogin method")
//			},
//			SetInfoFunc: func(login string, token string)  {
//				panic("mock out the SetInfo method")
//			},
//		}
//
//		// use mockedUserService in code that requires client.UserService
//		// and then make assertions.
//
//	}
type UserServiceMock struct {
	// GetBearerTokenFunc mocks the GetBearerToken method.
	GetBearerTokenFunc func() string

	// GetUserLoginFunc mocks the GetUserLogin method.
	GetUserLoginFunc func() string

	// SetInfoFunc mocks the SetInfo method.
	SetInfoFunc func(login string, token string)

	// calls tracks calls to the methods.
	calls struct {
		// GetBearerToken holds details about calls to the GetBearerToken method.
		GetBearerToken []struct {
		}
		// GetUserLogin holds details about calls to the GetUserLogin method.
		GetUserLogin []struct {
		}
		// SetInfo holds details about calls to the SetInfo method.
		SetInfo []struct {
			// Login is the login argument value.
			Login string
			// Token is the token argument value.
			Token string
		}
	}
	lockGetBearerToken sync.RWMutex
	lockGetUserLogin   sync.RWMutex
	lockSetInfo        sync.RWMutex
}

// GetBearerToken calls GetBearerTokenFunc.
func (mock *UserServiceMock) GetBearerToken() string {
	callInfo := struct {
	}{}
	mock.lockGetBearerToken.Lock()
	mock.calls.GetBearerToken = append(mock.calls.GetBearerToken, callInfo)
	mock.lockGetBearerToken.Unlock()
	if mock.GetBearerTokenFunc == nil {
		var (
			s string
		)
		return s
	}
	return mock.GetBearerTokenFunc()
}

// GetBearerTokenCalls gets all the calls that were made to GetBearerToken.
// Check the length with:
//
//	len(mockedUserService.GetBearerTokenCalls())
func (mock *UserServiceMock) GetBearerTokenCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetBearerToken.RLock()
	calls = mock.calls.GetBearerToken
	mock.lockGetBearerToken.RUnlock()
	return calls
}

// GetUserLogin calls GetUserLoginFunc.
func (mock *UserServiceMock) GetUserLogin() string {
	callInfo := struct {
	}{}
	mock.lockGetUserLogin.Lock()
	mock.calls.GetUserLogin = append(mock.calls.GetUserLogin, callInfo)
	mock.lockGetUserLogin.Unlock()
	if mock.GetUserLoginFunc == nil {
		var (
			s string
		)
		return s
	}
	return mock.GetUserLoginFunc()
}

// GetUserLoginCalls gets all the calls that were made to GetUserLogin.
// Check the length with:
//
//	len(mockedUserService.GetUserLoginCalls())
func (mock *UserServiceMock) GetUserLoginCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetUserLogin.RLock()
	calls = mock.calls.GetUserLogin
	mock.lockGetUserLogin.RUnlock()
	return calls
}

// SetInfo calls SetInfoFunc.
func (mock *UserServiceMock) SetInfo(login string, token string) {
	callInfo := struct {
		Login string
		Token string
	}{
		Login: login,
		Token: token,
	}
	mock.lockSetInfo.Lock()
	mock.calls.SetInfo = append(mock.calls.SetInfo, callInfo)
	mock.lockSetInfo.Unlock()
	if mock.SetInfoFunc == nil {
		return
	}
	mock.SetInfoFunc(login, token)
}

// SetInfoCalls gets all the calls that were made to SetInfo.
// Check the length with:
//
//	len(mockedUserService.SetInfoCalls())
func (mock *UserServiceMock) SetInfoCalls() []struct {
	Login string
	Token string
} {
	var calls []struct {
		Login string
		Token string
	}
	mock.lockSetInfo.RLock()
	calls = mock.calls.SetInfo
	mock.lockSetInfo.RUnlock()
	return calls
}
